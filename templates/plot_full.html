<!doctype html>
<html lang="it">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/jpeg" href="{{ url_for('favicon_jpg') }}" sizes="32x32" />
    <link rel="shortcut icon" type="image/jpeg" href="{{ url_for('favicon_jpg') }}" />
    <title>MC-Impact • Plot</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
      :root { --brand-bg:#fefefe; --brand-text:#1a1d21; --brand-accent:#2c7be5; }
      html, body { height: 100%; margin: 0; background: var(--brand-bg); color: var(--brand-text); }
      /* Forza testi neri su tutte le pagine plot */
      body { color:#000 !important; }
      header, #plot { color:#000 !important; }
      #root { position: absolute; inset: 0; display: flex; flex-direction: column; }
      header { padding: 8px 12px; font-family: system-ui, Arial, sans-serif; border-bottom: 1px solid #eee; display:flex; gap:12px; align-items:center; justify-content:center; flex-wrap:wrap; }
      header a { color: var(--brand-accent); text-decoration: none; }
      .brand { display:flex; justify-content:center; align-items:center; gap:12px; }
      /* Loghi unificati: cars dimensione standard, scritta metà */
      .brand img { width:auto; display:block; margin:0; }
      .brand img:last-child { max-height: 140px; }
      #brandLogo { max-height: 70px; }
      #controls { display:flex; gap:8px; align-items:center; }
      #plot { flex: 1; }
      header span { display:none; }
    </style>
  </head>
  <body>
    <div id="root">
      <header>
        <div class="brand">
          <img id="brandLogo" src="{{ url_for('logo_scritta') }}" alt="Logo scritta">
          <img src="{{ url_for('logo_cars') }}" alt="Logo cars">
        </div>
        <a href="{{ url_for('index') }}">Home</a>
        <span>•</span>
        
        <div id="controls"></div>
      </header>
      <div id="plot"></div>
    </div>

    <script>
      // RIMOSSO: Theme from logo (campionamento automatico)
      const kind = {{ kind|tojson }};
      const runId = {{ run_id|tojson }};
      // Imposta titolo pagina e separatore header
      try { document.title = 'MC-Impact-Plot'; const sep = document.querySelector('header span'); if (sep) sep.textContent='-'; } catch(e) {}

      function el(tag, attrs={}, children=[]) {
        const e = document.createElement(tag);
        Object.entries(attrs).forEach(([k,v]) => e.setAttribute(k,v));
        children.forEach(c => e.appendChild(typeof c === 'string' ? document.createTextNode(c) : c));
        return e;
      }
      function addZoomCtrl(){
        const ctrls = document.getElementById('controls');
        if (!ctrls) return;
        ctrls.innerHTML = '';
        // Title position sliders
        const labX = el('label', {}, ['Titolo X ']);
        const inX = el('input', { id:'titleX', type:'range', min:'0', max:'1', step:'0.01', value:'0.50', style:'width:140px;' });
        labX.appendChild(inX);
        const labY = el('label', {}, ['Y ']);
        const inY = el('input', { id:'titleY', type:'range', min:'0', max:'1', step:'0.01', value:'0.95', style:'width:140px;' });
        labY.appendChild(inY);
        // Zoom slider
        const labZ = el('label', {}, [ 'Zoom ' ]);
        const inZ = el('input', { id:'zoom', type:'range', min:'0.5', max:'2.0', step:'0.01', value:'1.00', style:'width:180px;' });
        labZ.appendChild(inZ);
        ctrls.appendChild(labX); ctrls.appendChild(labY); ctrls.appendChild(document.createTextNode(' | ')); ctrls.appendChild(labZ);
      }

      function deg2rad(d){ return d * Math.PI / 180; }
      function vec(x,y, len, angDeg) { const a = deg2rad(angDeg); return {x: x + len*Math.cos(a), y: y + len*Math.sin(a)}; }
      function arrow(x0,y0, x1,y1, color, name) { return { type: 'scatter', x:[x0,x1], y:[y0,y1], mode:'lines', line:{color, width:2}, name }; }
      function legendCorner(c){ const map={tr:[1,1,'right','top'], tl:[0,1,'left','top'], br:[1,0,'right','bottom'], bl:[0,0,'left','bottom']}; return map[c]||map.tr; }
      function buildLayoutControls(){
        const ctrls = document.getElementById('controls');
        if (!ctrls) return;
        let wrap = document.getElementById('layout-ctrls');
        if (!wrap){
          wrap = document.createElement('div');
          wrap.id = 'layout-ctrls';
          wrap.style.display='flex'; wrap.style.gap='8px'; wrap.style.alignItems='center';
          ctrls.appendChild(wrap);
        }
        wrap.innerHTML = `
          <span>Posizione titolo</span>
          <label>X <input id=\"tx\" type=\"range\" min=\"0\" max=\"1\" step=\"0.01\" value=\"0.5\" style=\"width:120px;\"></label>
          <label>Y <input id=\"ty\" type=\"range\" min=\"0\" max=\"1\" step=\"0.01\" value=\"0.95\" style=\"width:120px;\"></label>
          <span>|</span>
          <label>Legenda
            <select id=\"leg\">
              <option value=\"tr\">in alto a destra</option>
              <option value=\"tl\">in alto a sinistra</option>
              <option value=\"br\">in basso a destra</option>
              <option value=\"bl\">in basso a sinistra</option>
            </select>
          </label>`;
        function apply(){ const v=legendCorner(document.getElementById('leg').value); Plotly.relayout('plot', {'title.x':parseFloat(document.getElementById('tx').value),'title.y':parseFloat(document.getElementById('ty').value),'legend.x':v[0],'legend.y':v[1],'legend.xanchor':v[2],'legend.yanchor':v[3]}); }
        document.getElementById('tx').oninput=apply; document.getElementById('ty').oninput=apply; document.getElementById('leg').onchange=apply;
      }

      async function loadInputs() {
        const res = await fetch(`/api/run/${runId}/graph_inputs`);
        const data = await res.json();
        return data;
      }

      function buildScatterControls(variabili, colonne_errori) {
        const xSel = el('select', { id:'selX' }, variabili.map(v=>el('option',{},[v])));
        const ySel = el('select', { id:'selY' }, variabili.map(v=>el('option',{},[v])));
        const cSel = el('select', { id:'selC' }, colonne_errori.map(v=>el('option',{},[v])));
        xSel.selectedIndex = 0; ySel.selectedIndex = Math.min(1, variabili.length-1); cSel.selectedIndex = 0;
        const label = el('span',{},['Seleziona: X, Y, Colorbar']);
        const container = document.getElementById('controls');
        container.append(label, xSel, ySel, cSel);
        async function render() {
          const x = xSel.value, y = ySel.value, c = cSel.value;
          const r = await fetch(`/api/run/${runId}/scatter?x=${encodeURIComponent(x)}&y=${encodeURIComponent(y)}&c=${encodeURIComponent(c)}&limit=200000`);
          const d = await r.json();
          const trace = { x: d.x, y: d.y, mode: 'markers', type: 'scatter', marker: { color: d.c, colorscale: 'Viridis', showscale: true, size: 6, opacity: 0.7 } };
          const layout = { xaxis: { title: x }, yaxis: { title: y }, margin: { t: 40, l:60, r:10, b:60 }, title: `${y} in funzione di ${x}` };
          Plotly.newPlot('plot', [trace], layout, {responsive:true});
        }
        xSel.addEventListener('change', render); ySel.addEventListener('change', render); cSel.addEventListener('change', render);
        render();
      }

      function drawVectors(g) {
        const scale = 0.04;
        const v1pre = vec(g.x1, g.y1, scale*g.V1_pre, g.theta1_in);
        const v1post= vec(g.x1, g.y1, scale*g.V1_post, g.theta1_out);
        const v2pre = vec(g.x2, g.y2, scale*g.V2_pre, g.theta2_in);
        const v2post= vec(g.x2, g.y2, scale*g.V2_post, g.theta2_out);
        const traces = [
          arrow(g.x1, g.y1, v1pre.x, v1pre.y, 'rgb(102,179,255)', 'V1 pre'),
          arrow(g.x1, g.y1, v1post.x, v1post.y, 'rgb(0,0,255)', 'V1 post'),
          arrow(g.x2, g.y2, v2pre.x, v2pre.y, 'rgb(255,128,128)', 'V2 pre'),
          arrow(g.x2, g.y2, v2post.x, v2post.y, 'rgb(255,0,0)', 'V2 post')
        ];

        const shapes = [];
        const annotations = [
          {x:g.x1, y:g.y1, text:'G1', showarrow:false, font:{color:'blue', size:12}},
          {x:g.x2, y:g.y2, text:'G2', showarrow:false, font:{color:'red', size:12}}
        ];
        const arrs = [
          {x0:g.x1, y0:g.y1, x1:v1pre.x, y1:v1pre.y, color:'rgb(102,179,255)'},
          {x0:g.x1, y0:g.y1, x1:v1post.x,y1:v1post.y, color:'rgb(0,0,255)'},
          {x0:g.x2, y0:g.y2, x1:v2pre.x, y1:v2pre.y, color:'rgb(255,128,128)'},
          {x0:g.x2, y0:g.y2, x1:v2post.x,y1:v2post.y, color:'rgb(255,0,0)'}
        ];
        for (const a of arrs){ annotations.push({ x:a.x1, y:a.y1, ax:a.x0, ay:a.y0, xref:'x', yref:'y', axref:'x', ayref:'y', showarrow:true, arrowhead:3, arrowsize:1, arrowwidth:1.6, arrowcolor:a.color }); }
        // Punto origine
        traces.push({type:'scatter', x:[0], y:[0], mode:'markers', marker:{color:'black', size:6}, showlegend:false});
        // Cerchio guida attorno a G1 (raggio = |V1_post| in scala)
        const rG1 = Math.hypot(v1post.x-g.x1, v1post.y-g.y1);
        { const xs=[],ys=[]; const n=64; for(let i=0;i<=n;i++){ const a=2*Math.PI*i/n; xs.push(g.x1 + rG1*Math.cos(a)); ys.push(g.y1 + rG1*Math.sin(a)); } traces.push({type:'scatter', x:xs, y:ys, mode:'lines', line:{color:'blue', width:1}, hoverinfo:'skip', showlegend:false}); }
        annotations.push({x:g.x1+rG1, y:g.y1, text:'0°', showarrow:false, font:{color:'rgb(102,179,255)', size:10}});
        // Archi degli angoli
        function arcPts(cx,cy,r,deg){ const a1=deg*Math.PI/180; const n=Math.max(6,Math.round(Math.abs(deg)/6)); const xs=[],ys=[]; for(let i=0;i<=n;i++){ const t=i/n; const a=t*a1; xs.push(cx + r*Math.cos(a)); ys.push(cy + r*Math.sin(a)); } return [xs,ys]; }
        const arcs=[
          {cx:g.x1, cy:g.y1, r:0.5, ang:g.theta1_in,  color:'rgb(102,179,255)'},
          {cx:g.x1, cy:g.y1, r:0.7, ang:g.theta1_out, color:'rgb(0,0,255)'},
          {cx:g.x2, cy:g.y2, r:0.5, ang:g.theta2_in,  color:'rgb(255,128,128)'},
          {cx:g.x2, cy:g.y2, r:0.7, ang:g.theta2_out, color:'rgb(255,0,0)'}
        ];
        for (const ar of arcs){ const ap=arcPts(ar.cx,ar.cy,ar.r,ar.ang); traces.push({type:'scatter', x:ap[0], y:ap[1], mode:'lines', line:{color:ar.color, width:1.5}, hoverinfo:'skip', showlegend:false}); const mid=ar.ang*Math.PI/180/2; annotations.push({x:ar.cx+ar.r*1.1*Math.cos(mid), y:ar.cy+ar.r*1.1*Math.sin(mid), text: Math.round(ar.ang)+'°', showarrow:false, font:{color:ar.color, size:10}}); }
        if (g.PDOF_stima != null) {
          const r = 5; const a = deg2rad(g.PDOF_stima);
          shapes.push({type:'line', x0:-Math.cos(a)*r, y0:-Math.sin(a)*r, x1:Math.cos(a)*r, y1:Math.sin(a)*r, line:{dash:'dash', color:'magenta', width:2}});
          annotations.push({x:Math.cos(a)*r*1.05, y:Math.sin(a)*r*1.05, text: g.PDOF_stima.toFixed(1)+'°', showarrow:false, font:{color:'magenta'}});
        }
        const titleAnn = {xref:'paper', yref:'paper', x:0.5, y:1.05, text:'Rappresentazione vettoriale (1 unit\u00E0 grafica = 25 km/h)', showarrow:false, font:{size:16}};
        annotations.push(titleAnn);
        // Aggiunge una traccia in legenda per la PDOF stimata (linea magenta tratteggiata)
        if (g.PDOF_stima != null) {
          const rL = 5; const aL = deg2rad(g.PDOF_stima);
          traces.push({type:'scatter', x:[-Math.cos(aL)*rL, Math.cos(aL)*rL], y:[-Math.sin(aL)*rL, Math.sin(aL)*rL], mode:'lines', line:{dash:'dash', color:'magenta', width:2}, name:'PDOF stimata'});
        }
        // Rimuove eventuale circonferenza non richiesta attorno a G1 e l'etichetta '0°'
        const cleanedTraces = traces.filter(t => !(t && t.type==='scatter' && t.mode==='lines' && t.line && (t.line.color==='blue' || t.line.color==='#0000ff') && Array.isArray(t.x) && t.x.length>50 && !t.name));
        const ann = annotations.filter(a => !(a && typeof a.text==='string' && a.text.trim().startsWith('0')));
        const layout = { xaxis:{scaleanchor:'y', title:'X [m]'}, yaxis:{title:'Y [m]'}, showlegend:true, legend:{x:1,y:1,xanchor:'right',yanchor:'top'}, shapes, annotations: ann, margin:{t:60,l:60,r:10,b:60} };
        Plotly.newPlot('plot', cleanedTraces, layout, {responsive:true, scrollZoom:true, edits:{legendPosition:true, annotationPosition:true}});
        buildLayoutControls();
      }

      function drawTriangoli(t) {
        const scale = 0.04;
        const v1pre = vec(t.x1, t.y1, scale*t.V1_pre, t.theta1_in_t);
        const v1post= vec(t.x1, t.y1, scale*t.V1_post_t, t.theta1_out_t);
        const v2pre = vec(t.x2, t.y2, scale*t.V2_pre, t.theta2_in_t);
        const v2post= vec(t.x2, t.y2, scale*t.V2_post_t, t.theta2_out_t);
        const dv1 = { x: v1post.x - v1pre.x, y: v1post.y - v1pre.y };
        const dv2 = { x: v2post.x - v2pre.x, y: v2post.y - v2pre.y };
        const traces = [
          arrow(t.x1, t.y1, v1pre.x, v1pre.y, 'rgb(102,179,255)', 'V1 pre'),
          arrow(t.x1, t.y1, v1post.x, v1post.y, 'rgb(0,0,255)', 'V1 post'),
          arrow(t.x2, t.y2, v2pre.x, v2pre.y, 'rgb(255,128,128)', 'V2 pre'),
          arrow(t.x2, t.y2, v2post.x, v2post.y, 'rgb(255,0,0)', 'V2 post'),
          // ΔV vectors
          arrow(v1pre.x, v1pre.y, v1pre.x + dv1.x, v1pre.y + dv1.y, 'rgb(0,153,0)', 'ΔV1'),
          arrow(v2pre.x, v2pre.y, v2pre.x + dv2.x, v2pre.y + dv2.y, 'rgb(0,153,0)', 'ΔV2')
        ];
        const shapes = [];
        const annotations = [
          {x:t.x1, y:t.y1, text:'G1', showarrow:false, font:{color:'blue', size:12}},
          {x:t.x2, y:t.y2, text:'G2', showarrow:false, font:{color:'red', size:12}}
        ];
        const arrs = [
          {x0:t.x1, y0:t.y1, x1:v1pre.x, y1:v1pre.y, color:'rgb(102,179,255)'},
          {x0:t.x1, y0:t.y1, x1:v1post.x,y1:v1post.y, color:'rgb(0,0,255)'},
          {x0:t.x2, y0:t.y2, x1:v2pre.x, y1:v2pre.y, color:'rgb(255,128,128)'},
          {x0:t.x2, y0:t.y2, x1:v2post.x,y1:v2post.y, color:'rgb(255,0,0)'},
          {x0:v1pre.x, y0:v1pre.y, x1:v1pre.x + dv1.x, y1:v1pre.y + dv1.y, color:'rgb(0,153,0)'},
          {x0:v2pre.x, y0:v2pre.y, x1:v2pre.x + dv2.x, y1:v2pre.y + dv2.y, color:'rgb(0,153,0)'}
        ];
        for (const a of arrs){ annotations.push({ x:a.x1, y:a.y1, ax:a.x0, ay:a.y0, xref:'x', yref:'y', axref:'x', ayref:'y', showarrow:true, arrowhead:3, arrowsize:1, arrowwidth:1.6, arrowcolor:a.color }); }
        if (t.PDOF_eff != null) {
          const r = 5; const a = deg2rad(t.PDOF_eff);
          shapes.push({type:'line', x0:-Math.cos(a)*r, y0:-Math.sin(a)*r, x1:Math.cos(a)*r, y1:Math.sin(a)*r, line:{dash:'dash', color:'black', width:2}});
          annotations.push({x:Math.cos(a)*r*1.05, y:Math.sin(a)*r*1.05, text: t.PDOF_eff.toFixed(1)+'°', showarrow:false});
          // legend trace as well
          traces.push({type:'scatter', x:[-Math.cos(a)*r, Math.cos(a)*r], y:[-Math.sin(a)*r, Math.sin(a)*r], mode:'lines', line:{dash:'dash', color:'black', width:2}, name:'PDOF effettiva'});
        }
        const titleAnn2 = {xref:'paper', yref:'paper', x:0.5, y:1.05, text:'Chiusura triangoli', showarrow:false, font:{size:16}};
        annotations.push(titleAnn2);
        const layout = { xaxis:{scaleanchor:'y', title:'X [m]'}, yaxis:{title:'Y [m]'}, showlegend:true, legend:{x:1,y:1,xanchor:'right',yanchor:'top'}, shapes, annotations, margin:{t:60,l:60,r:10,b:60} };
        Plotly.newPlot('plot', traces, layout, {responsive:true, scrollZoom:true, edits:{legendPosition:true, annotationPosition:true}});
      }

      function drawCicloidi(c) {
        const traces = [];
        if (c.x1 && c.y1) traces.push({type:'scatter', mode:'lines', x:c.x1, y:c.y1, name:`Cicloide 1: theta=${(c.theta1||0).toFixed?c.theta1.toFixed(2):c.theta1}, R=${(c.R1||0).toFixed?c.R1.toFixed(2):c.R1}, L=${(c.L1||0).toFixed?c.L1.toFixed(2):c.L1}`});
        if (c.x2 && c.y2) traces.push({type:'scatter', mode:'lines', x:c.x2, y:c.y2, name:`Cicloide 2: theta=${(c.theta2||0).toFixed?c.theta2.toFixed(2):c.theta2}, R=${(c.R2||0).toFixed?c.R2.toFixed(2):c.R2}, L=${(c.L2||0).toFixed?c.L2.toFixed(2):c.L2}`});
        if (c.A1) traces.push({type:'scatter', mode:'markers+text', x:[c.A1[0]], y:[c.A1[1]], text:['A1'], textposition:'top right', marker:{color:'black', symbol:'circle'}, showlegend:false});
        if (c.B1) traces.push({type:'scatter', mode:'markers+text', x:[c.B1[0]], y:[c.B1[1]], text:['B1'], textposition:'bottom right', marker:{color:'red', symbol:'circle'}, showlegend:false});
        if (c.A2) traces.push({type:'scatter', mode:'markers+text', x:[c.A2[0]], y:[c.A2[1]], text:['A2'], textposition:'top left', marker:{color:'black', symbol:'square'}, showlegend:false});
        if (c.B2) traces.push({type:'scatter', mode:'markers+text', x:[c.B2[0]], y:[c.B2[1]], text:['B2'], textposition:'bottom left', marker:{color:'red', symbol:'square'}, showlegend:false});
        if (c.A1 && c.ang1 != null) {
          const L=3, a=deg2rad(c.ang1);
          traces.push({type:'scatter', mode:'lines', x:[c.A1[0]-L*Math.cos(a), c.A1[0]+L*Math.cos(a)], y:[c.A1[1]-L*Math.sin(a), c.A1[1]+L*Math.sin(a)], line:{color:'green', dash:'dash'}, name:`Retta tangente 1: \u03B1=${(c.ang1||0).toFixed?c.ang1.toFixed(2):c.ang1}\u00B0`});
        }
        if (c.A2 && c.ang2 != null) {
          const L=3, a=deg2rad(c.ang2);
          traces.push({type:'scatter', mode:'lines', x:[c.A2[0]-L*Math.cos(a), c.A2[0]+L*Math.cos(a)], y:[c.A2[1]-L*Math.sin(a), c.A2[1]+L*Math.sin(a)], line:{color:'magenta', dash:'dash'}, name:`Retta tangente 2: \u03B1=${(c.ang2||0).toFixed?c.ang2.toFixed(2):c.ang2}\u00B0`});
        }
        const titleAnn3 = {xref:'paper', yref:'paper', x:0.5, y:1.05, text:'Cicloidi post-urto', showarrow:false, font:{size:16}};
        const layout = { xaxis:{scaleanchor:'y'}, yaxis:{}, margin:{t:60,l:60,r:10,b:60}, showlegend:true, legend:{x:1,y:1,xanchor:'right',yanchor:'top'}, annotations:[titleAnn3] };
        Plotly.newPlot('plot', traces, layout, {responsive:true, scrollZoom:true, edits:{legendPosition:true, annotationPosition:true}});
      }

      function sign(x){ return x>=0?1:-1; }
      function mod360(deg){ return ((deg%360)+360)%360; }
      function toDeg(rad){ return rad*180/Math.PI; }
      function toRad(deg){ return deg*Math.PI/180; }

      function drawPDOFCone(data, useEff=false) {
        const meta = data._meta || {}; const params = meta.parametri||{}; const targets = meta.targets||{};
        const t = data.vectors; // use riga_minima fields
        if (!t) return;

        const V1_pre = (t.V1_pre||0)/3.6, V1_post=(t.V1_post||0)/3.6, V2_pre=(t.V2_pre||0)/3.6, V2_post=(t.V2_post||0)/3.6;
        const th1_in = t.theta1_in||0, th1_out=t.theta1_out||0, th2_in=t.theta2_in||0, th2_out=t.theta2_out||0;
        const J1 = t.J1||0, J2=t.J2||0;
        const w1_pre=t.omega1_pre||0, w1_post=t.omega1_post||0, w2_pre=t.omega2_pre||0, w2_post=t.omega2_post||0;
        const x1=t.x1||0, y1=t.y1||0, x2=t.x2||0, y2=t.y2||0;
        const m1 = params.m1? (Array.isArray(params.m1)? params.m1[0]: params.m1) : 1;
        const m2 = params.m2? (Array.isArray(params.m2)? params.m2[0]: params.m2) : 1;

        function diffVec(vpre, a1, vpost, a2) {
          const ax1 = toRad(a1), ax2 = toRad(a2);
          const vx1 = vpre*Math.cos(ax1), vy1 = vpre*Math.sin(ax1);
          const vx2 = vpost*Math.cos(ax2), vy2 = vpost*Math.sin(ax2);
          const dx = vx2 - vx1, dy = vy2 - vy1;
          const mag = Math.hypot(dx,dy);
          const ang = mod360(toDeg(Math.atan2(dy,dx)));
          return [mag, ang];
        }
        const [dV1,_a1] = diffVec(V1_pre, th1_in, V1_post, th1_out);
        const [dV2,_a2] = diffVec(V2_pre, th2_in, V2_post, th2_out);
        const Imax1 = Math.abs(m1 * dV1), Imax2 = Math.abs(m2 * dV2);
        const h1_min = Math.abs(J1 * (w1_pre - w1_post) / (Imax1||1e-9));
        const h2_min = Math.abs(J2 * (w2_pre - w2_post) / (Imax2||1e-9));

        const r1 = Math.hypot(x1,y1), r2=Math.hypot(x2,y2);
        const thG1 = Math.atan2(y1,x1), thG2 = Math.atan2(y2,x2);
        const alfa1 = Math.asin(Math.min(1, h1_min / Math.max(r1,1e-9)));
        const alfa2 = Math.asin(Math.min(1, h2_min / Math.max(r2,1e-9)));
        const PDOF1 = (thG1 + Math.sign(w1_post) * -alfa1);
        const PDOF2 = (thG2 + Math.sign(w2_post) * -alfa2);

        function angolo_cardinale_nel_verso(PDOF, verso, theta_altro) {
          const card = [0, Math.PI/2, Math.PI, 3*Math.PI/2];
          function quad(theta){ if (0<=theta && theta<Math.PI/2) return 0; if (Math.PI/2<=theta && theta<Math.PI) return 1; if (Math.PI<=theta && theta<3*Math.PI/2) return 2; return 3; }
          const q = quad((theta_altro%(2*Math.PI)+2*Math.PI)%(2*Math.PI));
          const sx = card[q], dx = card[(q+1)%4];
          let dSx, dDx; if (verso===1){ dSx=(sx-PDOF+2*Math.PI)%(2*Math.PI); dDx=(dx-PDOF+2*Math.PI)%(2*Math.PI);} else { dSx=(PDOF-sx+2*Math.PI)%(2*Math.PI); dDx=(PDOF-dx+2*Math.PI)%(2*Math.PI);} 
          return dSx<dDx? sx: dx;
        }
        function angolo_cardinale(PDOF, verso, cardinali){
          if (verso===0) return PDOF; const arr=cardinali; let delta;
          if (verso===-1){ delta = arr.map(c=> (PDOF - c + 2*Math.PI)%(2*Math.PI)); }
          else { delta = arr.map(c=> (c - PDOF + 2*Math.PI)%(2*Math.PI)); }
          let idx = 0, min=1e9; for (let i=0;i<delta.length;i++){ if (delta[i]<min){min=delta[i]; idx=i;} }
          return arr[idx];
        }

        const verso1 = -Math.sign(w1_post) || 0; const verso2 = -Math.sign(w2_post) || 0;
        const a = angolo_cardinale_nel_verso(PDOF1%(2*Math.PI), verso1, thG2);
        const b = angolo_cardinale_nel_verso(PDOF2%(2*Math.PI), verso2, thG1);
        const cardinali = [a,b];
        let range1 = angolo_cardinale(PDOF1%(2*Math.PI), verso1, cardinali);
        let range2 = angolo_cardinale(PDOF2%(2*Math.PI), verso2, cardinali);

        const a1 = PDOF1%(2*Math.PI), a2 = PDOF2%(2*Math.PI);
        const a1_op = (a1+Math.PI)%(2*Math.PI), a2_op = (a2+Math.PI)%(2*Math.PI);

        const w1 = Imax1, w2 = Imax2;
        const r1_plot = Math.min(2, 2 * (w1/Math.max(w1,w2||1e-9)));
        const r2_plot = Math.min(2, 2 * (w2/Math.max(w1,w2||1e-9)));
        const r_max = Math.max(r1_plot, r2_plot, r1, r2) + 0.5;
        const r_anno = r_max * 1.08; // spazio per etichette gradi esterne

        const traces = [];
        function sector(t1, t2, r, color){
          t1=(t1+2*Math.PI)%(2*Math.PI); t2=(t2+2*Math.PI)%(2*Math.PI);
          const pts=[]; const step = 64; let wrap=false;
          if (t2 < t1) { wrap=true; }
          function pushArc(from,to){ for (let i=0;i<=step;i++){ const t=from + (to-from)*i/step; pts.push({theta: toDeg(t), r}); } }
          if (!wrap) pushArc(t1,t2); else { pushArc(t1,2*Math.PI); pushArc(0,t2); }
          // close to center
          pts.push({theta: pts[pts.length-1].theta, r:0}); pts.push({theta: pts[0].theta, r:0});
          traces.push({type:'scatterpolar', mode:'lines', r: pts.map(p=>p.r), theta: pts.map(p=>p.theta), fill:'toself', fillcolor:'rgba(0,128,0,0.25)', line:{width:0}, showlegend:false});
        }
        // sectors and their opposites
        sector(range1, a1, 2.5, 'green'); sector((range1+Math.PI)%(2*Math.PI), (a1+Math.PI)%(2*Math.PI), 2.5, 'green');
        sector(range2, a2, 2.5, 'green'); sector((range2+Math.PI)%(2*Math.PI), (a2+Math.PI)%(2*Math.PI), 2.5, 'green');

        // Opposite arcs at r_max (cosmetic like matplotlib)
        traces.push({type:'scatterpolar', r:[r_max, r_max], theta:[toDeg(a1_op), toDeg(a1)], mode:'lines', line:{color:'rgba(204,217,255,1)', width:2}, showlegend:false});
        traces.push({type:'scatterpolar', r:[r_max, r_max], theta:[toDeg(a2_op), toDeg(a2)], mode:'lines', line:{color:'rgba(255,204,204,1)', width:2}, showlegend:false});

        // Vectors (legend shows angle and opposite)
        function norm360(d){ d=((d%360)+360)%360; return d; }
        function pairLabel(deg){ const a=norm360(deg).toFixed(1), b=norm360(deg+180).toFixed(1); return `${a}° / ${b}°`; }
        const deg1 = a1*180/Math.PI; const deg2 = a2*180/Math.PI;
        traces.push({type:'scatterpolar', r:[0, r1_plot], theta:[0, toDeg(a1)], mode:'lines', line:{color:'blue', width:2}, name:`PDOF veicolo 1 (${pairLabel(deg1)})`});
        traces.push({type:'scatterpolar', r:[0, r2_plot], theta:[0, toDeg(a2)], mode:'lines', line:{color:'red', width:2}, name:`PDOF veicolo 2 (${pairLabel(deg2)})`});

        // Target, stima ed effettiva (ognuna con angolo e opposto)
        let targetDeg = null;
        if (targets && targets.PDOF && Array.isArray(targets.PDOF)) targetDeg = targets.PDOF[0];
        let effDeg = null;
        if (useEff) {
          effDeg = t.PDOF_eff ?? data.pdof?.eff ?? data.triangoli?.PDOF_eff;
          effDeg = effDeg !== undefined ? parseFloat(effDeg) : null;
        }

        // Mostra la PDOF target (nera tratteggiata) solo se NON siamo in modalità effettiva
        if (!useEff && targetDeg != null){ 
          const opp = (targetDeg+180)%360; 
          const name=`PDOF target (${pairLabel(targetDeg)})`; 
          traces.push({
            type:'scatterpolar', 
            r:[0,r_max], 
            theta:[0,targetDeg], 
            mode:'lines', 
            line:{dash:'dash', color:'black', width:1.5}, 
            name
          }); 
          traces.push({
            type:'scatterpolar', 
            r:[0,r_max], 
            theta:[0,opp], 
            mode:'lines', 
            line:{dash:'dash', color:'black', width:1.5}, 
            showlegend:false
          }); 
        }

        // Mostra la PDOF stimata (magenta tratteggiata) solo se NON siamo in modalità effettiva
        if (!useEff && t.PDOF_stima != null){ 
          const s = t.PDOF_stima; 
          const opp = (s+180)%360; 
          const name = `PDOF stimata (${pairLabel(s)})`; 
          traces.push({
            type:'scatterpolar', 
            r:[0,r_max], 
            theta:[0,s], 
            mode:'lines', 
            line:{dash:'dash', color:'magenta', width:1.5}, 
            name
          }); 
          traces.push({
            type:'scatterpolar', 
            r:[0,r_max], 
            theta:[0,opp], 
            mode:'lines', 
            line:{dash:'dash', color:'magenta', width:1.5}, 
            showlegend:false
          }); 
        }

        // Mostra la PDOF effettiva (nera, continua, spessa) solo in modalità effettiva
        if (effDeg != null){
          const opp = (effDeg+180)%360;
          const name = `PDOF effettiva (${pairLabel(effDeg)})`;
          traces.push({
            type:'scatterpolar',
            r:[0,r_max],
            theta:[0,effDeg],
            mode:'lines',
            line:{color:'black', width:2.2}, // nero, continua, spessa
            name,
            showlegend:true
          }); 
          traces.push({
            type:'scatterpolar',
            r:[0,r_max],
            theta:[0,opp], 
            mode:'lines',
            line:{color:'black', width:2.2}, 
            showlegend:false
          }); 
        }

        // G1, G2 markers
        traces.push({type:'scatterpolar', mode:'markers+text', r:[r1], theta:[toDeg(thG1)], marker:{color:'blue', size:8}, text:['G1'], textposition:'top center', showlegend:false});
        traces.push({type:'scatterpolar', mode:'markers+text', r:[r2], theta:[toDeg(thG2)], marker:{color:'red', size:8}, text:['G2'], textposition:'top center', showlegend:false});

        const layout = { showlegend:true, margin:{t:40,l:10,r:10,b:10}, polar:{ radialaxis:{visible:true, range:[0,r_max] } }, title: useEff? 'Cono di validità PDOF (effettiva)':'Cono di validità PDOF (stima)'};
        Plotly.newPlot('plot', traces, layout, {responsive:true});
        try { Plotly.relayout('plot', {title: ''}); } catch(e) {}
        // Migliora aspetto: etichette gradi e legenda in basso, pan/zoom abilitati
        (function(){
          const degA1 = (a1*180/Math.PI), degA2 = (a2*180/Math.PI);
          const labels = [];
          function fmt(d){ d=((d%360)+360)%360; return d.toFixed(1)+'\u00B0'; }
          function t(thetaDeg, color){ return {type:'scatterpolar', mode:'text', r:[r_max*1.08], theta:[thetaDeg], text:[fmt(thetaDeg)], textfont:{color, size:12}, showlegend:false, hoverinfo:'skip', cliponaxis:false}; }
          labels.push(t(degA1, 'blue')); labels.push(t(degA2, 'red'));
          const tgtN = (Number.isFinite(parseFloat(targetDeg)) ? parseFloat(targetDeg) : null);
          const stN = (Number.isFinite(parseFloat(t.PDOF_stima)) ? parseFloat(t.PDOF_stima) : null);
          if (tgtN!=null) { labels.push(t(tgtN, 'black')); labels.push(t((tgtN+180)%360, 'black')); }
          if (!useEff && stN!=null) { labels.push(t(stN, 'magenta')); labels.push(t((stN+180)%360, 'magenta')); }
          labels.push(t((degA1+180)%360, 'blue')); labels.push(t((degA2+180)%360, 'red'));
          try { Plotly.addTraces('plot', labels); } catch(e) {}
          const layout2 = { showlegend:true, legend:{orientation:'h', x:0.5, y:-0.12, xanchor:'center', yanchor:'top'}, margin:{t:60,l:20,r:20,b:60}, dragmode:'pan', polar:{ radialaxis:{visible:true, range:[0, r_max*1.08] } }, title:'Cono di validità della PDOF' };
          try { Plotly.react('plot', document.getElementById('plot').data||traces, layout2, {responsive:true, scrollZoom:true, edits:{legendPosition:true, annotationPosition:true}}); } catch(e) {}
          // Ensure no built-in title and set vertical legend on right
          try { Plotly.relayout('plot', {title: '', 'legend.orientation':'v', 'legend.x':1.02, 'legend.y':1, 'legend.xanchor':'left', 'legend.yanchor':'top', 'margin.r':160, 'margin.b':40}); } catch(e) {}
          // Update legend names with current angles (value and opposite)
          try {
            const gd = document.getElementById('plot');
            const data = gd.data || [];
            function norm(d){ d=((d%360)+360)%360; return d; }
            function pair(deg){ return `${norm(deg).toFixed(1)}\u00B0 / ${norm(deg+180).toFixed(1)}\u00B0`; }
            const d1 = pair(a1*180/Math.PI);
            const d2 = pair(a2*180/Math.PI);
            const targetName = (typeof targetDeg==='number') ? `PDOF target (${pair(targetDeg)})` : null;
            const stimaName = (!useEff && typeof t.PDOF_stima==='number') ? `PDOF stimata (${pair(t.PDOF_stima)})` : null;
            const effName = (useEff && typeof effDeg==='number') ? `PDOF effettiva (${pair(effDeg)})` : null;
            data.forEach((tr,i)=>{
              if (tr.type==='scatterpolar' && tr.mode==='lines' && tr.line){
                if (!tr.line.dash){
                  if (tr.line.color==='blue') Plotly.restyle('plot', {name: `PDOF veicolo 1 (${d1})`}, [i]);
                  if (tr.line.color==='red')  Plotly.restyle('plot', {name: `PDOF veicolo 2 (${d2})`}, [i]);
                  if (tr.line.color==='black' && effName) Plotly.restyle('plot', {name: effName}, [i]);
                } else if (tr.line.dash==='dash'){
                  if (tr.line.color==='black' && targetName) Plotly.restyle('plot', {name: targetName}, [i]);
                  if (tr.line.color==='magenta' && stimaName) Plotly.restyle('plot', {name: stimaName}, [i]);
                }
              }
            });
          } catch(e) {}
          // Build draggable title + label annotations
          (function(){
            const anns = [];
            const titleAnn = {
              xref:'paper', yref:'paper',
              x:0.5, y:0.95,
              text:'Cono di validità della PDOF',
              showarrow:false,
              font:{size:16}
            };
            anns.push(titleAnn);

            function addLabel(txt, color, x, y){
              anns.push({
                xref:'paper', yref:'paper',
                x, y, text:txt,
                showarrow:false,
                font:{color, size:12}
              });
            }
            function fmt(d){ d=((d%360)+360)%360; return d.toFixed(1)+'\u00B0'; }

            const rightX = 1.08, leftX = -0.08;
            let y0 = 0.82, step=0.06;

            // Etichette principali
            addLabel(fmt(degA1), 'blue', rightX, y0); y0-=step;
            addLabel(fmt(degA2), 'red',  rightX, y0); y0-=step;

            // Etichetta nera → effDeg se effettiva, altrimenti targetDeg
            const blackVal = (useEff && typeof effDeg === 'number') ? effDeg : tgtN;
            if (blackVal != null) {
              addLabel(fmt(blackVal), 'black', rightX, y0);
              y0-=step;
            }

            // Etichetta magenta solo se NON effettiva
            if (!useEff && stN!=null){
              addLabel(fmt(stN),'magenta', rightX, y0);
              y0-=step;
            }

            // lato sinistro
            let yL = 0.18;
            addLabel(fmt((degA1+180)%360), 'blue', leftX, yL); yL+=step;
            addLabel(fmt((degA2+180)%360), 'red',  leftX, yL); yL+=step;

            if (blackVal != null) {
              addLabel(fmt((blackVal+180)%360), 'black', leftX, yL);
              yL+=step;
            }
            if (!useEff && stN!=null){
              addLabel(fmt((stN+180)%360),'magenta', leftX, yL);
            }

            try { Plotly.relayout('plot', {annotations: anns}); } catch(e) {}

            // Wire title sliders
            const inX = document.getElementById('titleX');
            const inY = document.getElementById('titleY');
            function applyTitle(){
              const x=parseFloat(inX.value)||0.5;
              const y=parseFloat(inY.value)||0.95;
              const cur = (document.getElementById('plot').layout.annotations||anns).slice();
              cur[0] = {...cur[0], x, y};
              Plotly.relayout('plot', {annotations: cur});
            }
            if (inX && inY){
              inX.addEventListener('input', applyTitle);
              inY.addEventListener('input', applyTitle);
              applyTitle();
            }
          })();
          // Slider Zoom
          try { const z=document.getElementById('zoom'); if (z){ const base=r_max*1.08; const apply=()=>{ const f=parseFloat(z.value)||1; Plotly.relayout('plot', {'polar.radialaxis.range':[0, base*f]}); }; z.addEventListener('input', apply); apply(); } } catch(e) {}
        })();
      }

      (async function init(){
        const data = await loadInputs();

        if (kind === 'scatter') {
          const ctrls = document.getElementById('controls');
          buildScatterControls(
            (data._meta && data._meta.variabili) || [],
            (data._meta && data._meta.colonne_errori) || []
          );

        } else if (kind === 'vectors') {
          drawVectors(data.vectors);

        } else if (kind === 'triangoli') {
          drawTriangoli(data.triangoli);

        } else if (kind === 'cicloidi') {
          drawCicloidi(data.cicloidi || {});

        } else if (kind === 'pdof') {
          addZoomCtrl();
          drawPDOFCone(data, false); // stima/target

        } else if (kind === 'pdof_tri') {
          addZoomCtrl();
          drawPDOFCone(data, true);  // effettiva (usa effDeg anche per etichetta nera)
        }
      })();
    </script>
  </body>
  </html>
