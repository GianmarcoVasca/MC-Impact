<!doctype html>
<html lang="it">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/jpeg" href="{{ url_for('favicon_jpg') }}" sizes="32x32" />
    <link rel="shortcut icon" type="image/jpeg" href="{{ url_for('favicon_jpg') }}" />
    <title>MC-Impact - Risultati</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
      :root { --brand-bg:#fefefe; --brand-text:#000000; --brand-accent:#2c7be5; }
      body { font-family: system-ui, Arial, sans-serif; margin: 2rem; background: var(--brand-bg); color: #000 !important; }
      .grid { display: grid; grid-template-columns: 1fr 1fr; gap: .5rem; }
      .card { border: 1px solid #ddd; border-radius: 8px; padding: 1rem; max-width: 1100px; margin-left:auto; margin-right:auto; }
      table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
      th, td { border-bottom: 1px solid #eee; padding: 0.4rem; text-align: left; }
      .kv { display: grid; grid-template-columns: 240px auto 80px; gap: .25rem .5rem; align-items: baseline; }
      .btn { background: var(--brand-accent); color:#fff; padding:.5rem .8rem; border-radius:6px; text-decoration:none; display:inline-block; }
      h2 small a { background: var(--brand-accent); color:#fff; padding:.3rem .6rem; border-radius:6px; text-decoration:none; }
      .actions a { margin-right: .75rem; }
      .muted { color: #555; }
      #explora .row { margin-bottom: 0.9rem; }
      #explora label { font-size: 1rem; }
      #explora .muted { font-size: 1rem; }
      #explora input, #explora select { font-size: 1rem; }
      a { color: var(--brand-accent); }
      .brand { display:flex; justify-content:center; align-items:center; gap:16px; margin: .5rem 0 1rem; }
      .brand img { width:auto; display:block; }
      .brand img:last-child { max-height: 140px; }
      #brandLogo { max-height: 70px; }
      .progress { background:#f1f3f5; border-radius:6px; height:10px; overflow:hidden; display:none; }
      .progress .bar { background:linear-gradient(90deg, #2c7be5, #66a6ff); height:100%; width:0%; transition: width .25s ease; }
      .progress-info { display:none; font-size:.9rem; margin-top:.35rem; color:#333; }
      #esploraLog { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:.9rem; background:#fcfcfc; border:1px solid #eee; border-radius:6px; padding:.5rem .75rem; max-height:220px; overflow:auto; white-space:pre-wrap; }
    </style>
  </head>
  <body>
    <div class="brand">
      <img id="brandLogo" src="{{ url_for('logo_scritta') }}" alt="Logo scritta">
      <img src="{{ url_for('logo_cars') }}" alt="Logo cars">
    </div>
    <h1 style="text-align:center;">Risultati MonteCarlo</h1>

    <div class="grid">
      <div class="card">
        <h2>Migliore combinazione</h2>
        <div class="kv">
          {% for k, v in best.items() %}
            <div><strong>{{ k }}</strong></div>
            <div>{{ v }}</div>
            <div class="muted">{% if units and units.get(k) %}{{ units.get(k) }}{% endif %}</div>
          {% endfor %}
        </div>
      </div>

      <div class="card">
        <h2>Parametri usati</h2>
        <div class="kv">
          {% for section, items in used_params_grouped %}
            <div style="grid-column:1 / -1; margin-top:.25rem; font-weight:700; color:#333;">{{ section }}</div>
            {% for k, v in items.items() %}
              <div><strong>{{ k }}</strong></div>
              <div>{{ v }}</div>
              <div class="muted">{% if units and units.get(k) %}{{ units.get(k) }}{% endif %}</div>
            {% endfor %}
          {% endfor %}
        </div>
      </div>
    </div>

    <!-- Opzioni sempre visibile -->
    <div class="card" style="margin-top:1rem;">
      <h2>Opzioni</h2>
      <div class="actions" style="display:flex; flex-direction:column; gap:.5rem; align-items:flex-start;">
        {% if files_available['risultati.txt'] %}
          <a class="btn" href="{{ url_for('download', filename='risultati.txt') }}">risultati.txt</a>
        {% endif %}
        {% if files_available['listato.txt'] %}
          <a class="btn" href="{{ url_for('download', filename='listato.txt') }}">listato.txt</a>
        {% endif %}
        <a class="btn" style="background:#868e96;" href="{{ url_for('index') }}">Home</a>
      </div>
    </div>

    <!-- Grafico MonteCarlo interattivo sempre visibile -->
    <div class="card" style="margin-top:1rem;">
      <h2>Grafico MonteCarlo interattivo <small><a class="btn" href="{{ url_for('plot_full', kind='scatter', run_id=run_id) }}" target="_blank">Apri a schermo intero</a></small></h2>
      <div class="row">
        <label>Asse X</label>
        <select id="selX">
          {% for col in variabili %}<option value="{{ col }}">{{ col }}</option>{% endfor %}
        </select>
      </div>
      <div class="row">
        <label>Asse Y</label>
        <select id="selY">
          {% for col in variabili %}<option value="{{ col }}">{{ col }}</option>{% endfor %}
        </select>
      </div>
      <div class="row">
        <label>Colorbar</label>
        <select id="selC">
          {% for col in colonne_errori %}<option value="{{ col }}">{{ col }}</option>{% endfor %}
        </select>
      </div>
      <div id="scatter" style="height:480px;"></div>
    </div>

    <!-- Diagramma vettoriale sempre visibile -->
    <div class="card" style="margin-top:1rem;">
      <h2>Diagramma vettoriale <small><a class="btn" href="{{ url_for('plot_full', kind='vectors', run_id=run_id) }}" target="_blank">Apri a schermo intero</a></small></h2>
      <div id="ctrl-vectors" class="muted" style="display:flex; gap:.5rem; align-items:center; margin:.25rem 0 .5rem 0;">
        <span>Posizione titolo</span>
        <label>X <input id="vx" type="range" min="0" max="1" step="0.01" value="0.5" style="width:120px;"></label>
        <label>Y <input id="vy" type="range" min="0" max="1" step="0.01" value="0.95" style="width:120px;"></label>
        <span>|</span>
        <label>Legenda
          <select id="vleg">
            <option value="tr">in alto a destra</option>
            <option value="tl">in alto a sinistra</option>
            <option value="br">in basso a destra</option>
            <option value="bl">in basso a sinistra</option>
          </select>
        </label>
      </div>
      <div id="vectors" style="height:560px;"></div>
    </div>

    {% if flags and flags.chiusura_triangoli %}
    <div class="card" style="margin-top:1rem;">
      <h2>Chiusura triangoli <small><a class="btn" href="{{ url_for('plot_full', kind='triangoli', run_id=run_id) }}" target="_blank">Apri a schermo intero</a></small></h2>
      <div id="ctrl-triangoli" class="muted" style="display:flex; gap:.5rem; align-items:center; margin:.25rem 0 .5rem 0;">
        <span>Posizione titolo</span>
        <label>X <input id="tx" type="range" min="0" max="1" step="0.01" value="0.5" style="width:120px;"></label>
        <label>Y <input id="ty" type="range" min="0" max="1" step="0.01" value="0.95" style="width:120px;"></label>
        <span>|</span>
        <label>Legenda
          <select id="tleg">
            <option value="tr">in alto a destra</option>
            <option value="tl">in alto a sinistra</option>
            <option value="br">in basso a destra</option>
            <option value="bl">in basso a sinistra</option>
          </select>
        </label>
      </div>
      <div id="triangoli" style="height:560px;"></div>
    </div>
    {% endif %}

    {% if flags and flags.cicloide_avanzata %}
    <div class="card" style="margin-top:1rem;">
      <h2>Cicloidi post-urto <small><a class="btn" href="{{ url_for('plot_full', kind='cicloidi', run_id=run_id) }}" target="_blank">Apri a schermo intero</a></small></h2>
      <div id="ctrl-cicloidi" class="muted" style="display:flex; gap:.5rem; align-items:center; margin:.25rem 0 .5rem 0;">
        <span>Posizione titolo</span>
        <label>X <input id="cx" type="range" min="0" max="1" step="0.01" value="0.5" style="width:120px;"></label>
        <label>Y <input id="cy" type="range" min="0" max="1" step="0.01" value="0.95" style="width:120px;"></label>
        <span>|</span>
        <label>Legenda
          <select id="cleg">
            <option value="tr">in alto a destra</option>
            <option value="tl">in alto a sinistra</option>
            <option value="br">in basso a destra</option>
            <option value="bl">in basso a sinistra</option>
          </select>
        </label>
      </div>
      <div id="cicloidi" style="height:560px;"></div>
    </div>
    {% endif %}

    {% if flags and flags.stima_PDOF %}
    <div class="card" style="margin-top:1rem;">
      <h2>Cono di validità PDOF <small>
        <a href="{{ url_for('plot_full', kind='pdof', run_id=run_id) }}" target="_blank">Stima (schermo intero)</a>
        {% if flags.chiusura_triangoli %}
        - <a class="btn" href="{{ url_for('plot_full', kind='pdof_tri', run_id=run_id) }}" target="_blank">Effettiva (schermo intero)</a>
        {% endif %}
      </small></h2>
      <div id="ctrl-pdof" class="muted" style="display:flex; gap:.5rem; align-items:center; margin:.25rem 0 .5rem 0;">
        <label>Zoom <input id="pdofZoom" type="range" min="0.5" max="2.0" step="0.01" value="1.00" style="width:180px;"></label>
      </div>
      <div id="pdof" style="height:520px;"></div>
    </div>
    {% endif %}

    <div class="card" id="explora" style="margin-top:1rem;">
      <h2>Esplora variabilità</h2>
      <div class="row">
        <label for="selMetric">Metrica da monitorare</label>
        <select id="selMetric">
          {% for col in variabili %}<option value="{{ col }}">{{ col }}</option>{% endfor %}
          {% for col in colonne_errori %}<option value="{{ col }}">{{ col }}</option>{% endfor %}
        </select>
      </div>
      <div class="row">
        <label for="selVars">Variabili da espandere</label>
        <select id="selVars" multiple size="8" style="min-width: 320px;">
          {% if expandable_vars %}
            {% for k in expandable_vars %}<option value="{{ k }}" selected>{{ k }}</option>{% endfor %}
          {% endif %}
        </select>
      </div>
      <div class="row">
        <label>Parametri</label>
        <div class="muted">max_iter: <input id="itMax" type="number" value="20" min="1" style="width:90px;"> 
          passo: <input id="itPasso" type="number" step="0.1" value="1.0" style="width:90px;">
          soglia_salto: <input id="itSoglia" type="number" step="0.1" value="3.0" style="width:90px;"></div>
      </div>
      <div class="actions" style="display:flex; gap:.5rem; align-items:center;">
        <button id="btnEsplora" type="button" class="btn">esplora</button>
        <button id="btnTermina" type="button" class="btn" style="background:#dc3545;">termina</button>
      </div>
      <div class="progress" id="esploraProg"><div class="bar" id="esploraBar"></div></div>
      <div class="progress-info" id="esploraProgInfo">0% - in corso...</div>
      <div id="esploraOut" class="muted" style="margin-top:.5rem;"></div>
      <div id="esploraLog" style="margin-top:.5rem; display:none;"></div>
      <div id="esploraPlot" style="height:320px; margin-top:.5rem;"></div>
    </div>

    <script>
      const runId = {{ run_id|tojson }};
      const graphInputs = {{ graph_inputs|safe }};

      const selX = document.getElementById('selX');
      const selY = document.getElementById('selY');
      const selC = document.getElementById('selC');
      if (selX && selY && selC) {
        if (selX.options.length > 0) selX.selectedIndex = 0;
        if (selY.options.length > 1) selY.selectedIndex = 1;
        if (selC.options.length > 0) selC.selectedIndex = 0;

        async function loadScatter() {
          const x = selX.value, y = selY.value, c = selC.value;
          const res = await fetch(`/api/run/${runId}/scatter?x=${encodeURIComponent(x)}&y=${encodeURIComponent(y)}&c=${encodeURIComponent(c)}&limit=10000`);
          const data = await res.json();
          if (data.error) return;
          const trace = { x: data.x, y: data.y, mode: 'markers', type: 'scatter', marker: { color: data.c, colorscale: 'Viridis', showscale: true } };
          const layout = { xaxis: { title: x }, yaxis: { title: y }, margin: { t: 40 }, title: `${y} in funzione di ${x}` };
          Plotly.newPlot('scatter', [trace], layout, {responsive: true});
        }
        selX.addEventListener('change', loadScatter);
        selY.addEventListener('change', loadScatter);
        selC.addEventListener('change', loadScatter);
        loadScatter();
      }

      function deg2rad(d){ return d * Math.PI / 180; }
      function vec(x,y, len, angDeg) { const a = deg2rad(angDeg); return {x: x + len*Math.cos(a), y: y + len*Math.sin(a)}; }
      function arrow(x0,y0, x1,y1, color, name) { return { type: 'scatter', x:[x0,x1], y:[y0,y1], mode:'lines', line:{color, width:2}, name }; }
      function legendCorner(c){ const map={tr:[1,1,'right','top'], tl:[0,1,'left','top'], br:[1,0,'right','bottom'], bl:[0,0,'left','bottom']}; return map[c]||map.tr; }

      function drawVectors() {
        const g = graphInputs.vectors;
        if (!g || g.V1_pre == null) return;
        const scale = 0.04; // 1 unit grafica = 25 km/h
        const v1pre = vec(g.x1, g.y1, scale*g.V1_pre, g.theta1_in);
        const v1post= vec(g.x1, g.y1, scale*g.V1_post, g.theta1_out);
        const v2pre = vec(g.x2, g.y2, scale*g.V2_pre, g.theta2_in);
        const v2post= vec(g.x2, g.y2, scale*g.V2_post, g.theta2_out);

        const traces = [
          arrow(g.x1, g.y1, v1pre.x, v1pre.y, 'rgb(102,179,255)', 'V1 pre'),
          arrow(g.x1, g.y1, v1post.x, v1post.y, 'rgb(0,0,255)', 'V1 post'),
          arrow(g.x2, g.y2, v2pre.x, v2pre.y, 'rgb(255,128,128)', 'V2 pre'),
          arrow(g.x2, g.y2, v2post.x, v2post.y, 'rgb(255,0,0)', 'V2 post')
        ];

        const shapes = [];
        const annotations = [
          {x:g.x1, y:g.y1, text:'G1', showarrow:false, font:{color:'blue', size:12}},
          {x:g.x2, y:g.y2, text:'G2', showarrow:false, font:{color:'red', size:12}}
        ];
        // Arrowheads for vectors
        const arrs = [
          {x0:g.x1, y0:g.y1, x1:v1pre.x, y1:v1pre.y, color:'rgb(102,179,255)'},
          {x0:g.x1, y0:g.y1, x1:v1post.x,y1:v1post.y, color:'rgb(0,0,255)'},
          {x0:g.x2, y0:g.y2, x1:v2pre.x, y1:v2pre.y, color:'rgb(255,128,128)'},
          {x0:g.x2, y0:g.y2, x1:v2post.x,y1:v2post.y, color:'rgb(255,0,0)'}
        ];
        for (const a of arrs){ annotations.push({ x:a.x1, y:a.y1, ax:a.x0, ay:a.y0, xref:'x', yref:'y', axref:'x', ayref:'y', showarrow:true, arrowhead:3, arrowsize:1, arrowwidth:1.6, arrowcolor:a.color }); }
        // Punto origine
        traces.push({type:'scatter', x:[0], y:[0], mode:'markers', marker:{color:'black', size:6}, showlegend:false});
        // Cerchio guida attorno a G1 (raggio = |V1_post| in scala)
        const rG1 = Math.hypot(v1post.x-g.x1, v1post.y-g.y1);
        { const xs=[],ys=[]; const n=64; for(let i=0;i<=n;i++){ const a=2*Math.PI*i/n; xs.push(g.x1 + rG1*Math.cos(a)); ys.push(g.y1 + rG1*Math.sin(a)); } traces.push({type:'scatter', x:xs, y:ys, mode:'lines', line:{color:'blue', width:1}, hoverinfo:'skip', showlegend:false}); }
        annotations.push({x:g.x1+rG1, y:g.y1, text:'0°', showarrow:false, font:{color:'rgb(102,179,255)', size:10}});
        // Archi degli angoli
        function arcPts(cx,cy,r,deg){ const a1=deg*Math.PI/180; const n=Math.max(6,Math.round(Math.abs(deg)/6)); const xs=[],ys=[]; for(let i=0;i<=n;i++){ const t=i/n; const a=t*a1; xs.push(cx + r*Math.cos(a)); ys.push(cy + r*Math.sin(a)); } return [xs,ys]; }
        const arcs=[
          {cx:g.x1, cy:g.y1, r:0.5, ang:g.theta1_in,  color:'rgb(102,179,255)'},
          {cx:g.x1, cy:g.y1, r:0.7, ang:g.theta1_out, color:'rgb(0,0,255)'},
          {cx:g.x2, cy:g.y2, r:0.5, ang:g.theta2_in,  color:'rgb(255,128,128)'},
          {cx:g.x2, cy:g.y2, r:0.7, ang:g.theta2_out, color:'rgb(255,0,0)'}
        ];
        for (const ar of arcs){ const ap=arcPts(ar.cx,ar.cy,ar.r,ar.ang); traces.push({type:'scatter', x:ap[0], y:ap[1], mode:'lines', line:{color:ar.color, width:1.5}, hoverinfo:'skip', showlegend:false}); const mid=ar.ang*Math.PI/180/2; annotations.push({x:ar.cx+ar.r*1.1*Math.cos(mid), y:ar.cy+ar.r*1.1*Math.sin(mid), text: Math.round(ar.ang)+'°', showarrow:false, font:{color:ar.color, size:10}}); }

        if (g.PDOF_stima != null) {
          const r = 5;
          const a = deg2rad(g.PDOF_stima);
          // Mantiene la linea come shape e aggiunge anche una traccia per la legenda
          shapes.push({type:'line', x0:-Math.cos(a)*r, y0:-Math.sin(a)*r, x1:Math.cos(a)*r, y1:Math.sin(a)*r, line:{dash:'dash', color:'magenta', width:2}});
          traces.push({type:'scatter', x:[-Math.cos(a)*r, Math.cos(a)*r], y:[-Math.sin(a)*r, Math.sin(a)*r], mode:'lines', line:{dash:'dash', color:'magenta', width:2}, name:'PDOF stimata'});
          annotations.push({x:Math.cos(a)*r*1.05, y:Math.sin(a)*r*1.05, text: g.PDOF_stima.toFixed(1)+'°', showarrow:false, font:{color:'magenta'}});
        }

        // Rimuove eventuale circonferenza non richiesta (se introdotta in futuro)
        const filtered = traces.filter(t => !(t && t.type==='scatter' && t.mode==='lines' && t.line && (t.line.color==='blue' || t.line.color==='#0000ff') && Array.isArray(t.x) && t.x.length>50 && !t.name));
        const ann = annotations.filter(a => !(a && typeof a.text==='string' && a.text.trim().startsWith('0')));
        const layout = { title: {text:'Rappresentazione vettoriale (1 unit\u00E0 grafica = 25 km/h)', x:0.5, y:0.95}, xaxis:{scaleanchor:'y', title:'X [m]'}, yaxis:{title:'Y [m]'}, showlegend:true, legend:{x:1,y:1,xanchor:'right',yanchor:'top'}, shapes, annotations: ann };
        Plotly.newPlot('vectors', filtered, layout, {responsive:true});
        const vx=document.getElementById('vx'), vy=document.getElementById('vy'), vleg=document.getElementById('vleg');
        if (vx && vy && vleg){ function apply(){ const [lx,ly,lxa,lya]=legendCorner(vleg.value); Plotly.relayout('vectors', {'title.x':parseFloat(vx.value),'title.y':parseFloat(vy.value),'legend.x':lx,'legend.y':ly,'legend.xanchor':lxa,'legend.yanchor':lya}); } vx.oninput=apply; vy.oninput=apply; vleg.onchange=apply; }
      }

      function drawTriangoli() {
        const t = graphInputs.triangoli;
        if (!t || t.theta1_in_t == null) return;
        const scale = 0.04;
        const v1pre = vec(t.x1, t.y1, scale*t.V1_pre, t.theta1_in_t);
        const v1post= vec(t.x1, t.y1, scale*t.V1_post_t, t.theta1_out_t);
        const v2pre = vec(t.x2, t.y2, scale*t.V2_pre, t.theta2_in_t);
        const v2post= vec(t.x2, t.y2, scale*t.V2_post_t, t.theta2_out_t);
        // Delta-V vectors
        const dv1 = { x: v1post.x - v1pre.x, y: v1post.y - v1pre.y };
        const dv2 = { x: v2post.x - v2pre.x, y: v2post.y - v2pre.y };
        const traces = [
          arrow(t.x1, t.y1, v1pre.x, v1pre.y, 'rgb(102,179,255)', 'V1 pre'),
          arrow(t.x1, t.y1, v1post.x, v1post.y, 'rgb(0,0,255)', 'V1 post'),
          arrow(t.x2, t.y2, v2pre.x, v2pre.y, 'rgb(255,128,128)', 'V2 pre'),
          arrow(t.x2, t.y2, v2post.x, v2post.y, 'rgb(255,0,0)', 'V2 post'),
          // ΔV arrows from tip of pre to post
          arrow(v1pre.x, v1pre.y, v1pre.x + dv1.x, v1pre.y + dv1.y, 'rgb(0,153,0)', 'ΔV1'),
          arrow(v2pre.x, v2pre.y, v2pre.x + dv2.x, v2pre.y + dv2.y, 'rgb(0,153,0)', 'ΔV2')
        ];
        const shapes = [];
        const annotations = [
          {x:t.x1, y:t.y1, text:'G1', showarrow:false, font:{color:'blue', size:12}},
          {x:t.x2, y:t.y2, text:'G2', showarrow:false, font:{color:'red', size:12}}
        ];
        const arrs = [
          {x0:t.x1, y0:t.y1, x1:v1pre.x, y1:v1pre.y, color:'rgb(102,179,255)'},
          {x0:t.x1, y0:t.y1, x1:v1post.x,y1:v1post.y, color:'rgb(0,0,255)'},
          {x0:t.x2, y0:t.y2, x1:v2pre.x, y1:v2pre.y, color:'rgb(255,128,128)'},
          {x0:t.x2, y0:t.y2, x1:v2post.x,y1:v2post.y, color:'rgb(255,0,0)'},
          // ΔV heads
          {x0:v1pre.x, y0:v1pre.y, x1:v1pre.x + dv1.x, y1:v1pre.y + dv1.y, color:'rgb(0,153,0)'},
          {x0:v2pre.x, y0:v2pre.y, x1:v2pre.x + dv2.x, y1:v2pre.y + dv2.y, color:'rgb(0,153,0)'}
        ];
        for (const a of arrs){ annotations.push({ x:a.x1, y:a.y1, ax:a.x0, ay:a.y0, xref:'x', yref:'y', axref:'x', ayref:'y', showarrow:true, arrowhead:3, arrowsize:1, arrowwidth:1.6, arrowcolor:a.color }); }
        if (t.PDOF_eff != null) {
          const r = 5; const a = deg2rad(t.PDOF_eff);
          shapes.push({type:'line', x0:-Math.cos(a)*r, y0:-Math.sin(a)*r, x1:Math.cos(a)*r, y1:Math.sin(a)*r, line:{dash:'dash', color:'black', width:2}});
          annotations.push({x:Math.cos(a)*r*1.05, y:Math.sin(a)*r*1.05, text: t.PDOF_eff.toFixed(1)+' deg', showarrow:false});
          // Legend entry for PDOF effettiva
          traces.push({type:'scatter', x:[-Math.cos(a)*r, Math.cos(a)*r], y:[-Math.sin(a)*r, Math.sin(a)*r], mode:'lines', line:{dash:'dash', color:'black', width:2}, name:'PDOF effettiva'});
        }
        const layout = { title:{text:'Chiusura triangoli', x:0.5, y:0.95}, xaxis:{scaleanchor:'y', title:'X [m]'}, yaxis:{title:'Y [m]'}, showlegend:true, legend:{x:1,y:1,xanchor:'right',yanchor:'top'}, shapes, annotations };
        Plotly.newPlot('triangoli', traces, layout, {responsive:true});
        const tx=document.getElementById('tx'), ty=document.getElementById('ty'), tleg=document.getElementById('tleg');
        if (tx && ty && tleg){ function applyT(){ const [lx,ly,lxa,lya]=legendCorner(tleg.value); Plotly.relayout('triangoli', {'title.x':parseFloat(tx.value),'title.y':parseFloat(ty.value),'legend.x':lx,'legend.y':ly,'legend.xanchor':lxa,'legend.yanchor':lya}); } tx.oninput=applyT; ty.oninput=applyT; tleg.onchange=applyT; }
      }

      drawVectors();
      drawTriangoli();

      function drawCicloidi() {
        const c = graphInputs.cicloidi || {};
        if (!c.x1 || !c.x2) return;
        const traces = [
          {type:'scatter', mode:'lines', x:c.x1, y:c.y1, name:`Cicloide 1: Î¸=${(c.theta1||0).toFixed?c.theta1.toFixed(2):c.theta1}, R=${(c.R1||0).toFixed?c.R1.toFixed(2):c.R1}, L=${(c.L1||0).toFixed?c.L1.toFixed(2):c.L1}`},
          {type:'scatter', mode:'lines', x:c.x2, y:c.y2, name:`Cicloide 2: Î¸=${(c.theta2||0).toFixed?c.theta2.toFixed(2):c.theta2}, R=${(c.R2||0).toFixed?c.R2.toFixed(2):c.R2}, L=${(c.L2||0).toFixed?c.L2.toFixed(2):c.L2}`}
        ];
        const shapes = [];
        if (c.A1 && c.ang1 != null) {
          const L=3, a=deg2rad(c.ang1);
          shapes.push({type:'line', x0:c.A1[0]-L*Math.cos(a), y0:c.A1[1]-L*Math.sin(a), x1:c.A1[0]+L*Math.cos(a), y1:c.A1[1]+L*Math.sin(a), line:{color:'green', dash:'dash'}});
        }
        if (c.A2 && c.ang2 != null) {
          const L=3, a=deg2rad(c.ang2);
          shapes.push({type:'line', x0:c.A2[0]-L*Math.cos(a), y0:c.A2[1]-L*Math.sin(a), x1:c.A2[0]+L*Math.cos(a), y1:c.A2[1]+L*Math.sin(a), line:{color:'magenta', dash:'dash'}});
        }
        const layout = { title:{text:'Cicloidi post-urto', x:0.5, y:0.95}, xaxis:{scaleanchor:'y'}, yaxis:{}, shapes, showlegend:true, legend:{x:1,y:1,xanchor:'right',yanchor:'top'} };
        Plotly.newPlot('cicloidi', traces, layout, {responsive:true});
        const cx=document.getElementById('cx'), cy=document.getElementById('cleg');
        if (cx && cy && cleg){ function applyC(){ const [lx,ly,lxa,lya]=legendCorner(cleg.value); Plotly.relayout('cicloidi', {'title.x':parseFloat(cx.value),'title.y':parseFloat(cy.value),'legend.x':lx,'legend.y':ly,'legend.xanchor':lxa,'legend.yanchor':lya}); } cx.oninput=applyC; cy.oninput=applyC; cleg.onchange=applyC; }
      }
      drawCicloidi();

      // Full cone (same as fullscreen)
      async function drawPDOF() {
        const res = await fetch(`{{ url_for('api_graph_inputs', run_id=run_id) }}`);
        const data = await res.json();
        function draw(containerId, useEff){
          const meta = data._meta || {}; const params = meta.parametri||{}; const targets = meta.targets||{}; const t = data.vectors;
          if (!t) return;
          function toDeg(r){ return r*180/Math.PI } function toRad(d){ return d*Math.PI/180 }
          function diffVec(vpre,a1,vpost,a2){ const ax1=toRad(a1), ax2=toRad(a2); const vx1=vpre*Math.cos(ax1), vy1=vpre*Math.sin(ax1); const vx2=vpost*Math.cos(ax2), vy2=vpost*Math.sin(ax2); const dx=vx2-vx1, dy=vy2-vy1; return [Math.hypot(dx,dy), Math.atan2(dy,dx)] }
          const V1_pre=(t.V1_pre||0)/3.6, V1_post=(t.V1_post||0)/3.6, V2_pre=(t.V2_pre||0)/3.6, V2_post=(t.V2_post||0)/3.6;
          const [dV1] = diffVec(V1_pre,t.theta1_in||0,V1_post,t.theta1_out||0); const [dV2] = diffVec(V2_pre,t.theta2_in||0,V2_post,t.theta2_out||0);
          const m1 = params.m1? (Array.isArray(params.m1)? params.m1[0]: params.m1) : 1; const m2 = params.m2? (Array.isArray(params.m2)? params.m2[0]: params.m2) : 1;
          const Imax1=Math.abs(m1*dV1), Imax2=Math.abs(m2*dV2);
          const h1=Math.abs((t.J1||0)*((t.omega1_pre||0)-(t.omega1_post||0))/(Imax1||1e-9)); const h2=Math.abs((t.J2||0)*((t.omega2_pre||0)-(t.omega2_post||0))/(Imax2||1e-9));
          const r1=Math.hypot(t.x1||0,t.y1||0), r2=Math.hypot(t.x2||0,t.y2||0); const thG1=Math.atan2(t.y1||0,t.x1||0), thG2=Math.atan2(t.y2||0,t.x2||0);
          const a1=Math.asin(Math.min(1,h1/Math.max(r1,1e-9))), a2=Math.asin(Math.min(1,h2/Math.max(r2,1e-9)));
          const P1=(thG1 + Math.sign(t.omega1_post||0) * -a1), P2=(thG2 + Math.sign(t.omega2_post||0) * -a2);
          function acv(PDOF, verso, theta_altro){ const card=[0,Math.PI/2,Math.PI,3*Math.PI/2]; function quad(th){ if(0<=th && th<Math.PI/2) return 0; if(Math.PI/2<=th && th<Math.PI) return 1; if(Math.PI<=th && th<3*Math.PI/2) return 2; return 3; } const q=quad((theta_altro%(2*Math.PI)+2*Math.PI)%(2*Math.PI)); const sx=card[q], dx=card[(q+1)%4]; let dS, dD; if(verso===1){ dS=(sx-PDOF+2*Math.PI)%(2*Math.PI); dD=(dx-PDOF+2*Math.PI)%(2*Math.PI);} else { dS=(PDOF-sx+2*Math.PI)%(2*Math.PI); dD=(PDOF-dx+2*Math.PI)%(2*Math.PI);} return dS<dD ? sx : dx; }
          function ac(PDOF, verso, arr){ if(verso===0) return PDOF; let d; if(verso===-1){ d=arr.map(c=>(PDOF-c+2*Math.PI)%(2*Math.PI)); } else { d=arr.map(c=>(c-PDOF+2*Math.PI)%(2*Math.PI)); } let idx=0,min=1e9; for(let i=0;i<d.length;i++){ if(d[i]<min){min=d[i]; idx=i;} } return arr[idx]; }
          const v1=-Math.sign(t.omega1_post||0)||0, v2=-Math.sign(t.omega2_post||0)||0; const a=acv(P1%(2*Math.PI), v1, thG2); const b=acv(P2%(2*Math.PI), v2, thG1); const card=[a,b]; let rA=ac(P1%(2*Math.PI), v1, card); let rB=ac(P2%(2*Math.PI), v2, card);
          const A=P1%(2*Math.PI), B=P2%(2*Math.PI); const Aop=(A+Math.PI)%(2*Math.PI), Bop=(B+Math.PI)%(2*Math.PI);
          const W1=Imax1, W2=Imax2; const rp1=Math.min(2, 2*(W1/Math.max(W1,W2||1e-9))); const rp2=Math.min(2, 2*(W2/Math.max(W1,W2||1e-9))); const Rmax=Math.max(rp1,rp2,r1,r2)+0.5;
          const traces=[]; function sector(t1,t2,r){ t1=(t1+2*Math.PI)%(2*Math.PI); t2=(t2+2*Math.PI)%(2*Math.PI); const step=64; const pts=[]; function arc(f,t){ for(let i=0;i<=step;i++){ const th=f+(t-f)*i/step; pts.push({theta:toDeg(th), r}); }} if (t2<t1) {arc(t1,2*Math.PI); arc(0,t2);} else { arc(t1,t2); } pts.push({theta:pts[pts.length-1].theta, r:0}); pts.push({theta:pts[0].theta, r:0}); traces.push({type:'scatterpolar', mode:'lines', r:pts.map(p=>p.r), theta:pts.map(p=>p.theta), fill:'toself', fillcolor:'rgba(0,128,0,0.25)', line:{width:0}, showlegend:false}); }
          sector(rA,A,2.5); sector((rA+Math.PI)%(2*Math.PI),(A+Math.PI)%(2*Math.PI),2.5); sector(rB,B,2.5); sector((rB+Math.PI)%(2*Math.PI),(B+Math.PI)%(2*Math.PI),2.5);
          traces.push({type:'scatterpolar', r:[Rmax,Rmax], theta:[toDeg(Aop), toDeg(A)], mode:'lines', line:{color:'rgba(204,217,255,1)', width:2}, showlegend:false});
          traces.push({type:'scatterpolar', r:[Rmax,Rmax], theta:[toDeg(Bop), toDeg(B)], mode:'lines', line:{color:'rgba(255,204,204,1)', width:2}, showlegend:false});
          function norm(d){ d=((d%360)+360)%360; return d; }
          function pair(deg){ return `${norm(deg).toFixed(1)}\u00B0 / ${norm(deg+180).toFixed(1)}\u00B0`; }
          const dA = pair(toDeg(A)); const dB = pair(toDeg(B));
          traces.push({type:'scatterpolar', r:[0,rp1], theta:[0,toDeg(A)], mode:'lines', line:{color:'blue', width:2}, name:`PDOF veicolo 1 (${dA})`});
          traces.push({type:'scatterpolar', r:[0,rp2], theta:[0,toDeg(B)], mode:'lines', line:{color:'red', width:2}, name:`PDOF veicolo 2 (${dB})`});
          let target=null; if (!useEff && targets && targets.PDOF && Array.isArray(targets.PDOF)) target = targets.PDOF[0]; if (useEff && t.PDOF_eff != null) target = t.PDOF_eff; if (target!=null){ const opp=(target+180)%360; traces.push({type:'scatterpolar', r:[0,Rmax], theta:[0,target], mode:'lines', line:{dash:'dash', color:'black', width:1.5}, name:`PDOF target (${pair(target)})`}); traces.push({type:'scatterpolar', r:[0,Rmax], theta:[0,opp], mode:'lines', line:{dash:'dash', color:'black', width:1.5}, showlegend:false}); }
          if (!useEff && t.PDOF_stima != null){ const s=t.PDOF_stima; const opp=(s+180)%360; traces.push({type:'scatterpolar', r:[0,Rmax], theta:[0,s], mode:'lines', line:{dash:'dash', color:'magenta', width:1.5}, name:`PDOF stimata (${pair(s)})`}); traces.push({type:'scatterpolar', r:[0,Rmax], theta:[0,opp], mode:'lines', line:{dash:'dash', color:'magenta', width:1.5}, showlegend:false}); }
          traces.push({type:'scatterpolar', mode:'markers+text', r:[r1], theta:[toDeg(thG1)], marker:{color:'blue', size:8}, text:['G1'], textposition:'top center', showlegend:false});
          traces.push({type:'scatterpolar', mode:'markers+text', r:[r2], theta:[toDeg(thG2)], marker:{color:'red', size:8}, text:['G2'], textposition:'top center', showlegend:false});
          const titleAnn = {xref:'paper', yref:'paper', x:0.5, y:1.05, text:'Cono di validità PDOF', showarrow:false, font:{size:16}};
          const layout = { polar:{ radialaxis:{visible:true, range:[0,Rmax]} }, margin:{t:60,l:10,r:10,b:10}, showlegend:true, legend:{x:1,y:1,xanchor:'right',yanchor:'top'}, annotations:[titleAnn] };
          Plotly.newPlot(containerId, traces, layout, {responsive:true, scrollZoom:true, edits:{legendPosition:true, annotationPosition:true}});
          // Migliora aspetto: aggiunge etichette gradi e legenda in basso
          (function(){
            const rA = Rmax*1.08;
            function fmt(d){ d=((d%360)+360)%360; return d.toFixed(1)+'\u00B0'; }
            function t(thetaDeg, color){ traces.push({type:'scatterpolar', mode:'text', r:[rA], theta:[thetaDeg], text:[fmt(thetaDeg)], textfont:{color, size:12}, showlegend:false, hoverinfo:'skip', cliponaxis:false}); }
            t(toDeg(A), 'blue'); t(toDeg(B), 'red');
            if (target!=null) { t(target, 'black'); t((target+180)%360, 'black'); }
            if (!useEff && t.PDOF_stima!=null) { t(t.PDOF_stima, 'magenta'); t((t.PDOF_stima+180)%360, 'magenta'); }
            t((toDeg(A)+180)%360, 'blue'); t((toDeg(B)+180)%360, 'red');
            const layout2 = { polar:{ radialaxis:{visible:true, range:[0,Rmax*1.08]} }, margin:{t:60,l:10,r:10,b:50}, showlegend:true, legend:{orientation:'h', x:0.5, y:-0.12, xanchor:'center', yanchor:'top'}, annotations:[{xref:'paper', yref:'paper', x:0.5, y:0.95, text:'Cono di validit\u00E0 della PDOF', showarrow:false, font:{size:16}}] };
            try { Plotly.react(containerId, traces, layout2, {responsive:true, scrollZoom:true, edits:{legendPosition:true, annotationPosition:true}}); } catch(e) {}
            // Slider Zoom
            try { const z=document.getElementById('pdofZoom'); if (z){ const base=Rmax*1.08; const apply=()=>{ const f=parseFloat(z.value)||1; Plotly.relayout(containerId, {'polar.radialaxis.range':[0, base*f]}); }; z.addEventListener('input', apply); apply(); } } catch(e) {}
            // Make angle labels draggable as annotations positioned outside plot
            (function(){
              const gd = document.getElementById(containerId);
              const ann = (gd.layout.annotations||[]).slice();
              function add(txt,color,x,y){ ann.push({xref:'paper', yref:'paper', x, y, text:txt, showarrow:false, font:{color, size:12}}); }
              function fmt(d){ d=((d%360)+360)%360; return d.toFixed(1)+'\u00B0'; }
              const rightX=1.08, leftX=-0.08; let yR=0.82, step=0.06;
              add(fmt(toDeg(A)), 'blue', rightX, yR); yR-=step; add(fmt(toDeg(B)), 'red', rightX, yR); yR-=step;
              if (target!=null){ add(fmt(target), 'black', rightX, yR); yR-=step; }
              if (!useEff && t.PDOF_stima!=null){ add(fmt(t.PDOF_stima), 'magenta', rightX, yR); yR-=step; }
              let yL=0.18; add(fmt((toDeg(A)+180)%360),'blue', leftX, yL); yL+=step; add(fmt((toDeg(B)+180)%360),'red', leftX, yL); yL+=step; if (target!=null){ add(fmt((target+180)%360),'black', leftX, yL); yL+=step; } if (!useEff && t.PDOF_stima!=null){ add(fmt((t.PDOF_stima+180)%360),'magenta', leftX, yL); }
              try { Plotly.relayout(containerId, {annotations: ann}); } catch(e) {}
            })();
          })();
        }
        draw('pdof', false);
      }
      drawPDOF();

      // Titolo e legenda ora sono trascinabili: nessun controllo extra necessario.

      // Esplora handler
      const btnEsplora = document.getElementById('btnEsplora');
      const btnTermina = document.getElementById('btnTermina');
      btnEsplora.addEventListener('click', async ()=>{
        const m = document.getElementById('selMetric').value;
        const it = parseInt(document.getElementById('itMax').value||'20');
        const ps = parseFloat(document.getElementById('itPasso').value||'1');
        const sg = parseFloat(document.getElementById('itSoglia').value||'3');
        const out = document.getElementById('esploraOut');
        const prog = document.getElementById('esploraProg');
        const bar = document.getElementById('esploraBar');
        const pinf = document.getElementById('esploraProgInfo');
        const log = document.getElementById('esploraLog');
        out.textContent = 'Elaborazione in corso...';
        if (prog && bar && pinf){ prog.style.display='block'; pinf.style.display='block'; bar.style.width='0%'; }
        if (log){ log.style.display='block'; log.textContent=''; }
        let stopPoll=false; const seenIters=new Set();
        (async function poll(){ if(stopPoll) return; try{ const r=await fetch(`/api/esplora_progress/${runId}`); if(r.ok){ const s=await r.json(); const cur=Math.max(0,parseInt(s.current||0)); const tot=Math.max(1,parseInt(s.total||it)); const pct=Math.min(100,Math.round(cur*100/tot)); if(bar) bar.style.width=pct+'%'; if(pinf) pinf.textContent=`${pct}% - ${cur}/${tot}`+(s.done?' - completato':''); if (s.last && s.last.iter && !seenIters.has(s.last.iter)) { seenIters.add(s.last.iter); const L=s.last; const media=(L.media_output!=null && !Number.isNaN(L.media_output))? L.media_output.toFixed(3):'NaN'; const std=(L.deviazione_std!=null && !Number.isNaN(L.deviazione_std))? L.deviazione_std.toFixed(3):'NaN'; const low=(Number.isFinite(L.media_output)&&Number.isFinite(L.deviazione_std))? (L.media_output-3*L.deviazione_std):NaN; const high=(Number.isFinite(L.media_output)&&Number.isFinite(L.deviazione_std))? (L.media_output+3*L.deviazione_std):NaN; const bracket=(Number.isFinite(low)&&Number.isFinite(high))? ` [${low.toFixed(3)}, ${high.toFixed(3)}]`:''; if(log) { const n = (typeof L.campioni_validi==='number')? L.campioni_validi : undefined; const nS = (n!=null)? ` | n=${n}`:''; log.textContent+=`Iter ${L.iter.toString().padStart(2,' ')} | std=${std} | ${m}: ${media} +/- ${(Number.isNaN(L.deviazione_std)?'NaN':(3*L.deviazione_std).toFixed(3))}${bracket}${nS}\n`; log.scrollTop=log.scrollHeight; } } } } catch(e){} if(!stopPoll) setTimeout(poll,500); })();
      // Termina handler
      btnTermina.addEventListener("click", async ()=>{
        try {
          await fetch(`/api/esplora_cancel/${runId}`, {method:"POST"});
          const pinf = document.getElementById("esploraProgInfo");
          if (pinf) pinf.textContent = "Interruzione richiesta...";
        } catch(e) {}
      });
        const res = await fetch(`/api/esplora/${runId}`, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({metrica:m, max_iter:it, passo:ps, soglia_salto:sg, vars: (document.getElementById("selVars") ? Array.from(document.getElementById("selVars").selectedOptions).map(o=>o.value) : [])})});
        const data = await res.json();
        stopPoll = true;
        if (!res.ok){ out.textContent = data.error || 'Errore'; return; }
        const iters = data.iterazioni || [];
        if (iters.length===0){ out.textContent='Nessun dato'; return; }
        out.textContent = `Iterazioni: ${iters.length} - Salto rilevato: ${data.salto_rilevato?"si":"no"}`;
        const xs = iters.map(r=>r.iter), ys = iters.map(r=>r.deviazione_std);
        Plotly.newPlot('esploraPlot', [{x:xs, y:ys, type:'scatter', mode:'lines+markers', name:'std'}], {margin:{t:30}, title:`Deviazione std di ${m}`}, {responsive:true});
        if (bar) bar.style.width='100%'; if (pinf) pinf.textContent='100% - completato';
        if (log){ if (data.report){ let txt=data.report; try{ txt=txt.replaceAll('Range angoli (valore centrale', 'Range valori (valore centrale'); }catch(e){} log.textContent = txt; } }
      });
    </script>
  </body>
  </html>








